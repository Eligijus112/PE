#$Id: /R/local/durables/models.R 130 2006-05-04T08:34:58.464913Z mpiktas  $

#form1 <- formula(y~a/(1+b*exp(-c*trend)))#Simple Logistic
#form2 <- formula(y~a*exp(b*exp(c*trend)))#Gomperz
#form3 <- formula(log(d(y))~b+c*trend+d*trend^2) #cumulative normal
#form4 <- formula(log(d(y))~b+c*log(trend)+d*log(trend)^2) #cumulative lognormal
#form5 <- formula(y~d+a*exp(b*(1+trend)^c))#Weibull
#form6 <- formula(y~(a-exp(-(b+q)*trend))/(1+(b/q)*exp(-(b+q)*trend))) #extended logistic A
#form7 <- formula(y~(a-c*exp(-(b+q)*trend))/(1+c*(b/q)*exp(-(b+q)*trend))) #extended logistic B
#form8 <- formula(y~a/(1+exp(-c*trend))^d) #BERTALAnFFY GENERALISED LOGISTIC
#form9 <- formula(y~a/(1+exp(-c/q*(1+trend)^q))) #Flexible Logistic

#form34 <- formula(y/l(y)-1~c+b*log(l(y))) #Gomperz modified


form1 <- formula(y~a/(1+b*exp(-c*trend))) #***SIMPLE LOGISTIC
form2 <- formula(y~a*exp(-b*exp(-c*trend))) #***GOMPERZ 
form3 <- formula(log(d(y))~b+c*trend+d*trend^2) #*** CUMULATIVE NORMAL - noncomparable
form4 <- formula(log(d(y))~b+c*log(trend)+d*log(trend)^2) #*** CUMULATIVE LOG-NORMAL 
form5 <- formula(y~d+a*exp(b*(1+trend)^(c))) #***Weibull
form6 <- formula(y~(a-exp(-(b+q)*trend))/(1+(b/q)*exp(-(b+q)*trend))) #***EXTENDED LOGISTIC A
form7 <- formula(y~(a-c*exp(-(b+q)*trend))/(1+c*(b/q)*exp(-(b+q)*trend))) #***EXTENDED LOGISTIC B
form8 <- formula(y~a/(1+exp(-c*trend))^(d)) #***BERTALAUFFY GENERALISED LOGISTIC
form9 <- formula(y~a/(1+exp(-c*((1+trend)^q)/q ))) #***FLEXIBLE LOGISTIC
form10 <- formula(log(y)~b+c/(1+trend)) #***LOG RECIPROCAL
form11 <- formula(y~(a-l(y))*exp(b+c*trend)) #***MANSFIELD - modified
form12 <- formula(y~(a-l(y))*exp(1/(a-l(y))+b+c*trend)) #*** FLOYD-modified unstable
form13 <- formula(y~(a-l(y))*exp(d/(a-l(y))+b+c*trend)) #*** SHARIF KABIR - modified  unstable
form14 <- formula(log(d(y))~b+c*log(trend)^2) #*** modif CUMULATIVE LOG-NORMAL 
#form14 <- formula(y~-b/q+(1/q)*(a-l(y))^(q*(1+c)/(q-b*c))*exp(d+(b+q)*trend)^(q/(q-b*c))) '*** KKI - modified  - nonstable
form15 <- formula(log(log(y))~b+c*(trend+1)) #*** LINEAR GOMPERZ  

#**** AR ****
form16 <- formula(d(y)~b*l(y)*(a-l(y))) # ***MANSFIELD
form17 <- formula(d(y)~b*l(y)*(a-l(y))^2) #***FLOYD
form18 <- formula(d(y)~(b*l(y)*(a-l(y))^2)/(1-c*l(y))) #***SHARIF-KABIR
form19 <- formula(d(y)~b*l(y)*(a-l(y))*(a-c*l(y))) #***KKIII
form20 <- formula(y~l(y)+(b*l(y)^c)*(a-l(y))) #***NONSYMETRIC RESPONDING LOGISTIC 
form21 <- formula(y~l(y)+(c+b*l(y))*(a-l(y))) #***BASS-SKIADAS
form22 <- formula(d(y)~(c/q)*l(y)*(a-l(y)^q)) #***KKKII
form23 <- formula(d(y)~(a*l(y))*(b-l(y)^d)) #***JEULAND modfi
form24 <- formula(d(y)~(c*l(y))*(a-l(y))/(1+c*l(y))) #***KKKI
form25 <- formula(d(y)~b*l(y)*log(l(y))) #*** GOMPERZ 
form26 <- formula(y~l(y)*exp(c*(a-l(y)))) #*** SBB 
form27 <- formula(y~b*l(y)*exp(q)/(1+l(y)*(exp(q)-1))) #*** LOCAL LOGISTIC modified
form28 <- formula(log(d(y))~b+c*trend+d*log(l(y))) #***HARVEY- mixed 
form29 <- formula(y/l(y)-1~(b+c*l(y)+d/l(y)+e*log(l(y)))) #***EXTENDED RICCATI
form30 <- formula(y/l(y)-1~b+c*l(y)+d*l(y)^2) #***FLOYD modified
form31 <- formula(y/l(y)-1~(b*(a-l(y))^2)/(1-c*l(y))) #***SHARIF-KABIR modified
form32 <- formula(y/l(y)-1~(b*(a-l(y))*(d-l(y)))) #***KKIII modified
form33 <- formula(y/l(y)-1~(c/q)*(a-l(y)^q)) #***KKKII modified
form34 <- formula(y/l(y)-1~c+b*log(l(y))) #*** GOMPERZ modified
form35 <- formula(d(log(y))~b+c*l(y)) #*** SBB modified
form36 <- formula(log(d(y))~b+c*log(trend)) #*** modif CUMULATIVE LOG-NORMAL

attr(form1,"cr") <- function(p) if(p[1]>0 & p[2]>0 & p[3]>0) TRUE else FALSE
attr(form2,"cr") <- function(p) if(p[1]>0 & p[2]>0 & p[3]>0) TRUE else FALSE
attr(form3,"cr") <- NULL
attr(form4,"cr") <- NULL
attr(form5,"cr") <- function(p) if(p[1]<0 & p[2]<0 & p[3]>1 & p[4]>0) TRUE else FALSE
attr(form5,"start") <- c(-1,-0.1,1.1,1)
attr(form6,"cr") <- function(p) if(p[1]>0 & p[2]>0 & p[3]>0) TRUE else FALSE
attr(form7,"cr") <- function(p) if(p[1]>0 & p[2]>0 & p[3]>0 & p[4]>0) TRUE else FALSE
attr(form8,"cr") <- function(p) if(p[1]>0 & p[2]>0 & p[3]>0) TRUE else FALSE
attr(form9,"cr") <- function(p) if(p[1]>0 & p[2]>0) TRUE else FALSE
attr(form10,"cr") <- function(p) if(p[2]<0) TRUE else FALSE
attr(form10,"start") <- c(0,-0.1)
attr(form11,"cr") <- function(p) if(p[1]>0 & p[3]>0) TRUE else FALSE
attr(form12,"cr") <- function(p) if(p[1]>0 & p[3]>0) TRUE else FALSE
attr(form13,"cr") <- function(p) if(p[1]>0 & p[3]>0) TRUE else FALSE
attr(form14,"cr") <- NULL
attr(form15,"cr") <- function(p) if(p[2]>0) TRUE else FALSE

attr(form16,"cr") <- function(p) if(p[1]>0 & p[2]>0) TRUE else FALSE
attr(form17,"cr") <- function(p) if(p[1]>0 & p[2]>0) TRUE else FALSE
attr(form18,"cr") <- function(p) if(p[1]>0 & p[2]>0 & p[3]>0 & p[3]<1) TRUE else FALSE
attr(form18,"start") <- c(1,0.1,0.5)
attr(form19,"cr") <- function(p) if(p[1]>0 & p[2]>0 & p[3]>0 & p[3]<p[1]) TRUE else FALSE

attr(form20,"cr") <- function(p) if(p[1]>0 & p[2]>0 & p[3]>0) TRUE else FALSE
attr(form21,"cr") <- function(p) if(p[1]>0 & p[2]>0 & p[3]>0) TRUE else FALSE
attr(form22,"cr") <- function(p) if(p[1]>0 & p[2]>0 & p[3]>-1) TRUE else FALSE
attr(form23,"cr") <- function(p) if(p[1]>0 & p[2]>0 & p[3]>0) TRUE else FALSE
attr(form24,"cr") <- function(p) if(p[1]>0) TRUE else FALSE
attr(form25,"cr") <- function(p) if(p[1]<0) TRUE else FALSE
attr(form25,"start") <- c(-0.1)
attr(form26,"cr") <- function(p) if(p[1]>0 & p[2]>0 & p[2]<1) TRUE else FALSE
attr(form27,"cr") <- function(p) if(p[1]>0 & p[2]>0) TRUE else FALSE
attr(form28,"cr") <- function(p) if(p[2]<0) TRUE else FALSE
attr(form28,"start") <- c(0.1,-0.1,0.1)
attr(form29,"cr") <- function(p) if(p[1]<0 & p[2]>0 & p[3]>0) TRUE else FALSE
attr(form29,"start") <- c(-0.2,0.1,0.1,0.1)
###attr(form30,"cr") <- function(p) if(p[1]>0 & p[2]>0 & p[3]>0) TRUE else FALSE



dforecast <- function (object, ...) UseMethod("dforecast")

batch <- function(y,range,esample) {
    fnames <- paste("form",(1:36)[-15],sep="")
    bfun <- function(fn) {
        teq <- try(eq(eval(parse(text=fn)),y,range,esample,control=list(maxit=10000)))
        if(class(teq)!="try-error") {
            #tfeq <- predict(teq,fsample)
            #list(list(model=teq$m,observed=teq$data,predicted=tfeq$data,control=list(outside=tfeq$outside,status="Fitted
	    #succecfully")))
            list(teq)
        }
        else {
            cat("\nModel ", fn ," failed ")
            list(control=list(status="Unsuccesfull fit"))
        }
    }
    res <- sapply(fnames,bfun)
}

sbatch <- function(y,range,esample,fsample,type="dynamic",outside=NA) {
    fnames <- paste("form",(1:36)[-15],sep="")
    bfun <- function(fn) {
        teq <- try(eq(eval(parse(text=fn)),y,range,esample,control=list(maxit=10000)))
        if(class(teq)!="try-error") {
            tfeq <- predict(teq,fsample,type=type,outside=outside)
            list(list(eq=teq,observed=teq$data,predicted=tfeq$data,control=list(outside=tfeq$outside,status="Fitted
	    succecfully")))
    
        }
        else {
            cat("\nModel ", fn," failed\n ")
            list(control=list(status="Unsuccesfull fit"))

        }
    }
    res <- sapply(fnames,bfun)
}

predict.batch <- function(b,fsample,type=NULL,outside=NULL) {
    #Assume that all data in batch has the same range
    ff <- lapply(b,predict.eq,sample=fsample,type=type,outside=outside)
    my <- sapply(ff,function(l)l$data$y)
    frange <- ff[[1]]$data$range
    obs <- rep(NA,length(frange)) 
    obs[frange%in% b[[1]]$data$range] <- b[[1]]$data$y
    list(my=my,range=frange,sample=fsample,smpl=frange%in%fsample,observed=obs)
}

se.pb <- function(pb) {
    res <- sweep(pb$my,1,pb$o,"-")
    se <- apply(res,2,sd,na.rm=TRUE)
    se
}

fpb <- function(pb,ind,weights=rep(1/length(ind),length(ind))) {
    if(is.null(weights)) {
        se <- 1/se.pb(pb)[ind]
        weights <- se/sum(se)
    }
    #Ensure that weights sum to 1 even for NA cases
    ##ww <- pb$my[,ind]
    ##ww[!is.na(ww)] <- 1
    ##ww[is.na(ww)] <- 0

    ##ww <- sweep(ww,2,weights,"*")
    ##ww <- sweep(ww,1,apply(ww,1,sum),"/")
    
    fc <- apply(sweep(pb$my[,ind],2,weights,"*"),1,sum)
     
    list(y=fc,range=pb$range,sample=pb$sample,smpl=pb$smpl)
}
plot.pb <- function(pb,ind,observed=TRUE,sample=NULL,new=TRUE,ylim=NULL) {
    if(is.null(sample))sample <- pb$range
    smpl <- pb$range%in%sample
    if(new) {
        #par(xaxs="i",yaxs="i")
        plot.new()
        if(is.null(ylim))ylim <- range(pb$my[smpl,ind],pb$o,na.rm=TRUE)
        plot.window(xlim=range(pb$range[smpl]),ylim=ylim)
        axis(1,at=my.at <- seq(min(pb$range),max(pb$range),by=5),labels=my.at)
        axis(2)
        box()
        title(xlab="Year",ylab="Penetration")
    }
    col <- rainbow(length(ind))
    for(i in 1:length(ind)) {
        lines(pb$range[smpl],pb$my[smpl,ind[i]],col=col[i])
    }
    if(observed)points(pb$range[smpl],pb$o[smpl],col=1)
    
}

plot.data <- function(data,new=TRUE,sample=NULL,col="black",type="l",main=NULL,xlim=NULL,ylim=NULL,...){
    if(is.null(sample))sample <- data$range
    smpl <- data$range%in%sample
    if(new) {
        x11()
        plot.new()
        if(is.null(xlim))xlim <- range(data$range[smpl])
        if(is.null(ylim))ylim <- range(data$y[smpl],na.rm=TRUE)
        plot.window(xlim=xlim,ylim=ylim)
        axis(1)
        axis(2)
        box()
        title(xlab="Year",ylab="Penetration",main=main)
    }
#    lines(eqf$p$range,eqf$p$y,col="red")
    switch(type,
           l=lines(data$range[smpl],data$y[smpl],col=col,...),
           p=points(data$range[smpl],data$y[smpl],col=col,...)
           )
     
}
select1 <- function(y,range,sample,cross=3) {
    n <- length(sample)
    res <- list()
    for(i in 1:cross) {
        esample <- sample[1]:sample[n-i]
        fsample <- sample[n-i+1]:sample[n]
        res <- c(res,list(sbatch(y,range,esample,fsample,type="dynamic",outside="NA")))
    }
    res
}

mape <- function(bl) {
    if(!is.null(bl$observed)) {
        fsample <- (max(bl$observed$sample)+1):max(bl$predicted$sample)
        y <-bl$observed$y[bl$observed$range %in% fsample]
        yhat <- bl$predicted$y[bl$predicted$range %in%fsample]
        sum(abs(y-yhat))
    }
    else NA
}

plot.fulleq <- function(eqf,new=TRUE){
    if(new) {
        plot.new()
        plot.window(xlim=range(eqf$p$range),ylim=range(eqf$p$y[eqf$p$smpl],eqf$o$y[eqf$o$smpl]))
        axis(1)
        axis(2)
        box()
        title(xlab="Year",ylab="Penetration")
    }
    lines(eqf$p$range,eqf$p$y,col="red")
    lines(eqf$o$range,eqf$o$y)
}
eq <- function(formula,y,range,sample,start=NULL,cr=attributes(formula)$cr,method="BFGS",...) {
    trend <- 1:length(range)-1
    #class(y) <- "ets"
    smpl <- range %in% sample
    #prepare start
    var.names <- all.vars(formula[[3]])
    var.names <- sort(var.names[var.names!="trend" & var.names!="y"])
    if(is.null(start)) {
        #start1 <- start2 <- list()
        #start1[var.names] <- 0
        #start2[var.names] <- 0.1
        #if(!is.null(start1$a))start2$a <- start1$a <- 1
        #if(!is.null(start1$q))start2$q <- start1$q <- 0.005

        #cand1 <- try(nlsBFGS(formula,data=data.frame(y=y[smpl],trend=trend[smpl]),start=start1,cr=cr,method="Nelder-Mead",control=list(maxit=100)))
        #cand2 <- try(nlsBFGS(formula,data=data.frame(y=y[smpl],trend=trend[smpl]),start=start2,cr=cr,method="Nelder-Mead",control=list(maxit=100)))
      

        #start <- list()
        #if (class(cand1)=="try-error") {
        #    if(class(cand2)=="try-error") {
        #        browser()
        #        stop("Model failed")
        #       
        #    }
        #    else start[var.names] <- cand2$optim$par
        #}
        #else {
        #    if(class(cand2)=="try-error") {
        #        start[var.names] <- cand1$optim$par
        #    }
        #    else {
        #     
        #        if(cand1$optim$value<cand2$optim$value)  {
        #            start[var.names] <- cand1$optim$par
        #        }
        #        else  {
        #            start[var.names] <- cand2$optim$par
        #        }
        #    }
        #}
        #browser()
        start <- list()
        if(is.null(attributes(formula)$start)) {
            start[var.names] <- 0.1
            if(!is.null(start$a)) start$a <- 1
            if(!is.null(start$q))start$q <- 0.005
        }
        else start[var.names] <- attributes(formula)$start

        cand <- try(nlsBFGS(formula,data=data.frame(y=y[smpl],trend=trend[smpl]),start=start,cr=cr,method="Nelder-Mead",control=list(maxit=100)))
        start <- list()
        start[var.names] <- cand$optim$par
        
        model <- try(nlsBFGS(formula,start=start,data=data.frame(y=y[smpl],trend=trend[smpl]),cr=cr,method="BFGS",...))
        if(class(model)=="try-error") {
            stop("Model failed")
            browser()
        }
         
    }
    else {
        snames <- sort(names(start))
        if(length(var.names)!=length(snames)) stop ("The number of provided parameters does not match number of parameters in formula")
        else if(sum(var.names!=sort(names(start)))!=0)
          stop("Names of provided parameters do not match the names of parameters in formula")
        model <- nlsBFGS(formula,data=data.frame(y=y[smpl],trend=trend[smpl]),start=start,cr=cr,method=method,...)
        #model <- nls(formula,data=data.frame(y=y[smpl],trend=trend[smpl]),start=start,...)
    }
   
    #data is the data we used to fit model
    #model is 
    res <- list(m=model,data=list(y=y,range=range,sample=sample,smpl=smpl))
    class(res) <- "eq"
    res
}

predict.eq <- function(object,sample,type=NULL,outside=NULL) {
    #If there are functions l or d in formula, use dynamic forecast
    #Find the names of functions used in formula
    lhs <- object$m$formula[[2]]
    rhs <- object$m$formula[[3]]
    fls <- all.names(lhs)
    fls <- fls[!(fls%in% all.vars(lhs))]
    frs <- all.names(rhs)
    frs <- frs[!(frs%in% all.vars(rhs))]
    #print(c(fls,frs))
    #Do the checking
    cc <- grep("^[ld]{1}$",c(fls,frs))
    if(is.null(outside))outside <- "NA"
    if (length(cc)!=0) {
        #print("Performing dynamic forecasting")
        #If model is dynamic, forecasting can be either static or dynamic.
        #Static forecasting makes sense only for original sample
        if(is.null(outside)) outside <- "fitted"
        if(is.null(type)) type <- "dynamic"
        if(type=="dynamic") res <- feqdyn(object,sample,outside)
        else res <- feqsd(object,sample,outside=outside)
    }
    else  {
        #print("Performing static forecasting")
        if(is.null(outside)) outside <- "fitted"
        res <- feqss(object,sample,outside)
    }
    res
}

plot.feq <- function(fq,xlim=NULL) {
    if(is.null(xlim))xlim <- range(fq$range)
    plot(fq$range,fq$y,type="l",xlim,xlab="Year",ylab="Penetration")
   
}

feqss <- function(eqo,sample,outside="fitted") {
    #Static forecast for static models
    #reconcile sample and range, the forecast range can increase, but not decrease.
    frange <- min(eqo$data$range,sample):max(eqo$data$range,sample)
    #use the trend the same as in estimated model
    trend <- frange-eqo$data$range[1]
    smpl <- frange %in% sample
    fc <- rep(NA,length(frange))
    fitt <- predict(eqo$m,newdata=data.frame(trend=trend))
    fc[smpl] <- fitt[smpl]
    asmpl <- frange %in% eqo$sample
    #Fill outside of the sample with NA's, insert actual values, or just leave fitted.
    switch(outside,
           fitted=fc[!smpl] <- fitt[!smpl],
           actual=fc[asmpl] <- eqo$data$y[eqo$data$smpl]
           )
    list(data=list(y=fc,range=frange,sample=sample,smpl=smpl),outside=outside)
}

feqsd <- function(eqo,sample,outside="actual") {
    #Static forecast for dynamic models
    rs <- range(sample)
    rd <- range(eqo$data$sample)
    if(rs[1]<rd[1] || rs[2]>rd[2]) {
        warning("Sample for static forecast is outside original data sample, reducing sample to fit ")
        le <- max(rs[1],rd[1])
        re <- min(rs[2],rd[2])
        sample <- sample[sample>=le & sample<=re]
    }
    #browser()
    frange <-  eqo$data$range
    fc <- rep(NA,length(frange))
    lhs <- eqo$m$formula[[2]]
    form <- inverse(lhs)
    el <- c(eqo$m$el,list(rs=eqo$m$fitted))
    fitt <- eval(form,el)
    fsmpl <- frange %in% sample
    asmpl <- eqo$data$sample%in%sample
    fc[fsmpl] <- fitt[asmpl]
    if(outside=="actual") {
        asmpl <- !(fsmpl)
        fc[asmpl] <- eqo$data$y[asmpl]
    }
   list(data=list(y=fc,range=frange,sample=sample,smpl=fsmpl),outside=outside)
}

feqdyn <- function(eqo,sample,outside="fitted") {
    if(sum(diff(sample)!=1)>0)stop("Dynamic forecasts are supported only for time with unit frequency")
    #test whether we have a begining
    #Todo: Count the number of lags, for now only one lag is permitted
    lag <- 1
    sample <- c(sample[1]-lag,sample)
    if(sample[1]<min(eqo$data$range))stop("Forecasting sample is outside data range")

    
    frange <- min(eqo$data$range):max(eqo$data$range,sample)
    smpl <- frange %in% sample
    fc <- rep(NA,length(frange))

    trend <- sample-eqo$data$range[1]
    sy <- eqo$data$y[eqo$data$range%in%sample[1]]
    if(is.na(sy))stop("Begining of dynamic forecast is NA")
    #browser()
    
    fc[smpl] <- dforecast(eqo$m,newdata=data.frame(y=c(sy,rep(NA,length(sample)-1)),trend))
    if(outside=="actual") {
        eqs <- eqo$data$sample[1]:min(sample[1],max(eqo$data$sample))
        fsmpl <- frange %in% eqs
        asmpl <- eqo$data$range %in% eqs
        fc[fsmpl] <- eqo$data$y[asmpl]

    }
    #browser()
    if(outside=="fitted") {
        #print("Not supported yet")
        #if(sample[1]==min(eqo$data$sample))print("Dynamic forecasting is done from the beginning of the sample")
        #else {
            lhs <- eqo$m$formula[[2]]
            form <- inverse(lhs)
            el <- c(eqo$m$el,list(rs=eqo$m$fitted))
            fitt <- eval(form,el)
            eqs <- eqo$data$sample[1]:sample[1]
            fsmpl <- frange %in% eqs
            asmpl <- eqo$data$sample%in%eqs
            fc[fsmpl] <- fitt[asmpl]
        #}
    }

    sample <- frange[min(which(!is.na(fc)))]:max(sample)
    list(data=list(y=fc,range=frange,sample=sample,smpl=frange%in%sample),outside=outside)
}

nlsBFGS <- function(formula,data,start,covmat=FALSE,cr=NULL,method="BFGS",...) {
    p <- unlist(start)
    if(is.null(cr))cr <- function(p)TRUE

    if(!cr(p)) stop("The initial coefficients do not satisfy constraints")
    #evaluation list
    el <- list()
    el <- c(start,as.list(na.omit(data)))
    lhs <- formula[[2]]
    rhs <- formula[[3]]
    
    ls <- eval(lhs,el)
    rs <- eval(rhs,el)
    res <- ls-rs
    inc <- !is.na(res) & abs(res)<Inf
    ssqres <- function(p) {
        if(cr(p)) {
            el[names(start)] <- lapply(p,function(l)l)
            ls <- eval(lhs,el)
            rs <- eval(rhs,el)
      
            sum((ls-rs)[inc]^2)
        }
        else NA
        
    }
    
    #Change l(y) to lagy, because the deriv does not know function l()
    drhs <- deparse(rhs,width=300)

    crhs <- gsub("l(y)","lagy",drhs,fixed=T)
    if(drhs!=crhs) {
        crhs <- formula(paste("~",crhs,sep=""))[[2]]
        el$lagy <- eval(formula(~l(y))[[2]],el)
    }
    else crhs <- rhs
    dss <- deriv(crhs,names(start))
    
    ssqgr <- function(p) {
        if(cr(p)) {
           
            el[names(start)] <- lapply(p,function(l)l)
            ls <- eval(lhs,el)
            dd <- eval(dss,el)
            rs <- dd
            attr(rs,"gradient") <- NULL
            grm <- -2*attributes(dd)$gradient*(ls-rs)
            gr <- apply(grm[inc,,drop=FALSE],2,sum)
            gr

        }
        else rep(NA,length(p))
    }
    fit <- optim(p,ssqres,ssqgr,method=method,hessian=TRUE,...)
    #fit <- optim(p,ssqres,method="Nelder-Mead",...)

    el[names(start)] <- lapply(fit$p,function(l)l)
    rs <- eval(rhs,el)
    ls <- eval(lhs,el)

    
    drhs <- eval(dss,el)
    df <- attributes(drhs)$gradient
    dm <- -2*df*(ls-rs)
    df <- df[inc,,drop=FALSE]
    dm <- dm[inc,,drop=FALSE]
    np <- dim(df)[2]
    ni <- sum(inc)
    
    if(covmat & method=="BFGS") {
      ##Calculate the covariance matrix of the parameters
        ##Covariance matrix is V^{-1}E(dm*dm')V^{-1}, where
        ##V=2*E(df*df')
        notes <- list(exit=0)
        if(np==1) {
            V <- sum(df^2)
            M <- sum(dm^2)
            covmat <- matrix(M/V^2/2,nrow=1)
        }
        else {
        #browser()
            V <- apply(df,1,function(o)outer(o,o))
            V <- 2*matrix(apply(V,1,sum),nrow=np)
            M <- apply(dm,1,function(o)outer(o,o))
            M <- 2*matrix(apply(M,1,sum),nrow=np)
            
            ## browser()
            
            Vinv <- try(solve(V))
                
            if(class(Vinv)=="try-error") {
                warning("Could not compute covariance matrix of parameters")
                                        #print("Failed matrix")
                                        #print(V)
                covmat <- V
                covmat[,] <- NA
                                        #browser()
                notes$V <- V
                                        #            notes$warnings <- c(notes$warnings,last.warning[[1]])
                notes$exit <- notes$exit+10
            }
                    else covmat <- Vinv%*%M%*%Vinv
        }    
        
       
    }
    else {
        covmat <- matrix(NA,nrow=length(p),ncol=length(p))
        notes <- list(exit=-9999)
    }

    if(ni>np) se <- sd((ls-rs)[inc])*sqrt((ni-1)/(ni-np))
       else {
           warning("There are no degrees of freedom of left")
           se <- sd((ls-rs)[inc])
           notes$exit <- notes$exit+100
       }
    out <- list(coefficients=fit$p,
                formula=formula,
                fitted=rs,
                residuals=ls-rs,
                gradient=ssqgr(fit$p),
                optim=fit,
                el=el,
                start=start,
                rhsderiv=dss,
                var.coef=diag(covmat),
                covmat=covmat,
                se=se,
                notes=notes
                )
               # fitted=eval(rhs,el))
    class(out) <- "nlsBFGS"
    out
}

predict.nlsBFGS <- function(model,newdata) {
    #Static forecast
    lhs <- model$formula[[2]]
    form <- inverse(lhs)
    rhs <- model$formula[[3]]
    el <- model$el
    el[names(newdata)] <- as.list(newdata)
    rs<- eval(rhs,el)
    el$rs <- rs
    eval(form,el)
}

dforecast.nlsBFGS <- function(model,newdata) {
    #Dynamic forecast
    lhs <- model$formula[[2]]
    rhs <- model$formula[[3]]
    n <- dim(newdata)[1]
    el <- model$el
    form <- inverse(lhs)
    if(is.null(form))stop("Prediction of this model is not supported. Please look at function inverse")
    for(i in 2:n) {
        el[names(newdata)] <- as.list(newdata[c(i-1,i),,drop=FALSE])
        rs <- eval(rhs,el)
        el$rs <- rs
        newdata$y[i] <- eval(form,el)[2]
    }
    newdata$y
}

#Dynamic standard error forecast
dsef.nlsBFGS <- function(model,newdata) {
    #Dynamic forecast
    lhs <- model$formula[[2]]
    rhs <- model$formula[[3]]
    n <- dim(newdata)[1]
    el <- model$el
    form <- inverse(lhs)
    if(!is.null(model$el$lagy))newdata$lagy <- l(newdata$y)
    newdata$se <- rep(NA,n)
    if(is.null(form))stop("Prediction of this model is not supported. Please look at function inverse")
    for(i in 2:n) {
        el[names(newdata)] <- as.list(newdata[c(i-1,i),,drop=FALSE])
        rs <- eval(model$rhsderiv,el)
        drhs <- attributes(rs)$gradient[2,,drop=FALSE]
        attr(rs,"gradient")<- NULL
        el$rs <- rs
        newdata$y[i] <- eval(form,el)[2]
        newdata$se[i] <- sum(drhs%*%(model$covmat%*%t(drhs)))
        newdata$lagy <- l(newdata$y)
    }
    newdata
}

inverse <- function(lhs) {
    
    if(!is.character(lhs)) lhs <- deparse(lhs)
    inv <- switch(lhs,
                  "log(d(y))"=formula(~l(y)+exp(rs)),
                  "d(y)"=formula(~l(y)+rs),
                  "y/l(y) - 1"=formula(~l(y)*(rs+1)),
                  "d(log(y))"=formula(~exp(l(log(y))+rs)),
                  "log(y)"=formula(~exp(rs)),
                  "y"=formula(~rs),
                  "log(log(y))"=formula(~exp(exp(rs))),
                  "other" =NULL
    )
    inv[[2]]
}
    

d <- function(x) {
    c(NA,diff(unclass(x)))
}
l <- function(x) {
    n <- length(x)
    c(NA,x[-n])
}

reverse.data <- function(data) {
    n <- length(data$y)
    data$y <- data$y[n:1]
    data
}
